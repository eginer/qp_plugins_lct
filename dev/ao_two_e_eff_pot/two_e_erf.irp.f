subroutine give_polynom_x_for_erf_int(                           &
      P_new,P_center,p,iorder_p,pq_inv,pq_inv_2,        &
      Q_new,Q_center,q,iorder_q,p10_1,p01_1,p10_2,p01_2,&
      n_Ix, Ix_pol)
  implicit none
  BEGIN_DOC
  ! You enter with two polynoms P_new and Q_new of order iorder_p and iorder_q 
  !
  ! centered in P_center and Q_center
  !
  ! each one multiplied by a gaussian of exponent p, q and centered in P_center and Q_center  
  !
  ! You go out with a polynom Ix_pol of order n_Ix which contains all powers in "t^2" 
  !
  ! generated by the integration over x1, x2 
  END_DOC
  include 'utils/constants.include.F'
  double precision, intent(in)   :: P_new(0:max_dim),P_center,p
  double precision, intent(in)   :: Q_new(0:max_dim),Q_center,q
  double precision, intent(in)   :: pq_inv, p10_1, p10_2, p01_1, p01_2,pq_inv_2
  integer, intent(in)            :: iorder_p
  integer, intent(in)            :: iorder_q

  double precision, intent(out)  :: Ix_pol(0:max_dim)
  integer, intent(out)           :: n_Ix

  double precision               :: dx(0:max_dim)
  integer                        :: nx
  integer                        :: ix,jx
  double precision               :: a,d,pq
  integer                        :: n_pt_tmp,n_pt_out, iorder


  !DIR$ ATTRIBUTES ALIGN : $IRP_ALIGN :: dx,Ix_pol
  if(iorder_p .lt.0 .or. iorder_q .lt.0 )then
   n_Ix = -1
   Ix_pol = 0.d0
   return
  endif
  ! Gaussian Product
  ! ----------------
  iorder = iorder_p+iorder_q+iorder_p+iorder_q
  !DIR$ VECTOR ALIGNED
  do ix=0,iorder
    Ix_pol(ix) = 0.d0
  enddo
  n_Ix = 0
  do ix = 0, iorder_p
    if (abs(P_new(ix)) < thresh) cycle
    a = P_new(ix)
    do jx = 0, iorder_q
      d = a*Q_new(jx)
      if (abs(d) < thresh) cycle
      !DEC$ FORCEINLINE
      call give_polynom_mult_center_x(P_center,Q_center,ix,jx,p,q,iorder,pq_inv,pq_inv_2,p10_1,p01_1,p10_2,p01_2,dx,nx)
      !DEC$ FORCEINLINE
      call add_poly_multiply(dx,nx,d,Ix_pol,n_Ix)
    enddo
  enddo
  if (n_Ix == -1) then
    return
  endif
end

double precision function general_primitive_integral_erf_new(dim,            &
      P_new,P_center,fact_p,p,p_inv,iorder_p,                        &
      Q_new,Q_center,fact_q,q,q_inv,iorder_q)
  implicit none
  BEGIN_DOC
  ! Computes the integral <pq|rs> where p,q,r,s are Gaussian primitives
  END_DOC
  integer,intent(in)             :: dim
  include 'utils/constants.include.F'
  double precision, intent(in)   :: P_new(0:max_dim,3),P_center(3),fact_p,p,p_inv
  double precision, intent(in)   :: Q_new(0:max_dim,3),Q_center(3),fact_q,q,q_inv
  integer, intent(in)            :: iorder_p(3)
  integer, intent(in)            :: iorder_q(3)

  double precision               :: rho,dist
  double precision               :: Ix_pol(0:max_dim,3)
  integer                        :: n_Ix(3),m,i
  double precision               :: accu,pq,const
  double precision               :: pq_inv, p10_1, p10_2, p01_1, p01_2,pq_inv_2
  integer                        :: n_pt_tmp,n_pt_out, iorder
  double precision               :: d1(0:max_dim),d_poly(0:max_dim),rint,d1_screened(0:max_dim)

  general_primitive_integral_erf_new = 0.d0

  !DIR$ ATTRIBUTES ALIGN : $IRP_ALIGN :: dx,Ix_pol,dy,Iy_pol,dz,Iz_pol
  !DIR$ ATTRIBUTES ALIGN : $IRP_ALIGN :: d1, d_poly

  ! Gaussian Product
  ! ----------------
  double precision :: p_plus_q
  p_plus_q = (p+q) * ((p*q)/(p+q) + mu_erf*mu_erf)/(mu_erf*mu_erf)
  pq = p_inv*0.5d0*q_inv

  pq_inv = 0.5d0/p_plus_q
  p10_1 = q*pq  ! 1/(2p)
  p01_1 = p*pq  ! 1/(2q)
  pq_inv_2 = pq_inv+pq_inv
  p10_2 = pq_inv_2 * p10_1*q !0.5d0*q/(pq + p*p)
  p01_2 = pq_inv_2 * p01_1*p !0.5d0*p/(q*q + pq)


  accu = 0.d0
  n_Ix = 0 
  Ix_pol = 0.d0
  ! You get the polynoms Ix_pol(:,1), Ix_pol(:,2), Ix_pol(:,3) for the x,y,z integration
  do m = 1, 3
   call give_polynom_x_for_erf_int(                                              &
       P_new(0,m),P_center(m),p,iorder_p(m),pq_inv,pq_inv_2,        &
       Q_new(0,m),Q_center(m),q,iorder_q(m),p10_1,p01_1,p10_2,p01_2,&
       n_Ix(m), Ix_pol(0,m))
   if(n_Ix(m) == -1) then
    return
   endif
  enddo

  rho = p*q *pq_inv_2  ! le rho qui va bien
  dist =  (P_center(1) - Q_center(1))*(P_center(1) - Q_center(1)) +  &
      (P_center(2) - Q_center(2))*(P_center(2) - Q_center(2)) +      &
      (P_center(3) - Q_center(3))*(P_center(3) - Q_center(3))
  const = dist*rho

  n_pt_tmp = n_Ix(1)+n_Ix(2)
  do i=0,n_pt_tmp
    d_poly(i)=0.d0
  enddo

  ! You multiply the polynom in x and Y to give d_poly
  !DEC$ FORCEINLINE
  call multiply_poly(Ix_pol(0,1),n_Ix(1),Ix_pol(0,2),n_Ix(2),d_poly,n_pt_tmp)
  if (n_pt_tmp == -1) then
    return
  endif
  n_pt_out = n_pt_tmp+n_Ix(3)
  do i=0,n_pt_out
    d1(i)=0.d0
  enddo

  ! You multiply d_poly with the polynom in z to get d1
  !DEC$ FORCEINLINE
  call multiply_poly(d_poly ,n_pt_tmp ,Ix_pol(0,3),n_Ix(3),d1,n_pt_out)
  double precision               :: rint_sum
  ! then you integrate over [0,1] d1(t) * exp(-const * t^2)
  accu = accu + rint_sum(n_pt_out,const,d1)

  ! change p+q in dsqrt
  general_primitive_integral_erf_new = fact_p * fact_q * accu *pi_5_2*p_inv*q_inv/dsqrt(p_plus_q)
end


double precision function ao_two_e_integral_schwartz_accel_erf_new(i,j,k,l)
  implicit none
  BEGIN_DOC
  !  integral of the AO basis <ik|jl> or (ij|kl)
  !     i(r1) j(r1) 1/r12 k(r2) l(r2)
  END_DOC
  integer,intent(in)             :: i,j,k,l
  integer                        :: p,q,r,s
  double precision               :: I_center(3),J_center(3),K_center(3),L_center(3)
  integer                        :: num_i,num_j,num_k,num_l,dim1,I_power(3),J_power(3),K_power(3),L_power(3)
  double precision               :: integral
  include 'utils/constants.include.F'
  double precision               :: P_new(0:max_dim,3),P_center(3),fact_p,pp
  double precision               :: Q_new(0:max_dim,3),Q_center(3),fact_q,qq
  integer                        :: iorder_p(3), iorder_q(3)
  double precision, allocatable  :: schwartz_kl(:,:)
  double precision               :: schwartz_ij
  double precision               :: general_primitive_integral_erf_new

  dim1 = n_pt_max_integrals

  num_i = ao_nucl(i)
  num_j = ao_nucl(j)
  num_k = ao_nucl(k)
  num_l = ao_nucl(l)
  ao_two_e_integral_schwartz_accel_erf_new = 0.d0
  double precision               :: thr
  thr = ao_integrals_threshold*ao_integrals_threshold

  allocate(schwartz_kl(0:ao_prim_num(l),0:ao_prim_num(k)))

      double precision               :: coef3
      double precision               :: coef2
      double precision               :: p_inv,q_inv
      double precision               :: coef1
      double precision               :: coef4

  if (num_i /= num_j .or. num_k /= num_l .or. num_j /= num_k)then
    do p = 1, 3
      I_power(p) = ao_power(i,p)
      J_power(p) = ao_power(j,p)
      K_power(p) = ao_power(k,p)
      L_power(p) = ao_power(l,p)
      I_center(p) = nucl_coord(num_i,p)
      J_center(p) = nucl_coord(num_j,p)
      K_center(p) = nucl_coord(num_k,p)
      L_center(p) = nucl_coord(num_l,p)
    enddo
 double precision :: P_new_ij(0:max_dim,3,ao_prim_num_max,ao_prim_num_max) ! new polynom for each couple of prim
 double precision :: P_center_ij(3,ao_prim_num_max,ao_prim_num_max) ! new center for each couple of prim
 double precision :: p_exp_ij(ao_prim_num_max,ao_prim_num_max) ! new gaussian exponents for each couple of prim
 double precision :: fact_p_ij(ao_prim_num_max,ao_prim_num_max) ! factor for each couple of primitive 
 integer          :: iorder_p_ij(3,ao_prim_num_max,ao_prim_num_max) ! order of the polynoms for each couple of prim
 double precision :: coef_prod_ij(ao_prim_num_max,ao_prim_num_max) ! produc of coef for each couple of primitive 

 double precision :: P_new_kl(0:max_dim,3,ao_prim_num_max,ao_prim_num_max) ! new polynom for each couple of prim
 double precision :: P_center_kl(3,ao_prim_num_max,ao_prim_num_max) ! new center for each couple of prim
 double precision :: p_exp_kl(ao_prim_num_max,ao_prim_num_max) ! new gaussian exponents for each couple of prim
 double precision :: fact_p_kl(ao_prim_num_max,ao_prim_num_max) ! factor for each couple of primitive 
 integer          :: iorder_p_kl(3,ao_prim_num_max,ao_prim_num_max) ! order of the polynoms for each couple of prim
 double precision :: coef_prod_kl(ao_prim_num_max,ao_prim_num_max) ! produc of coef for each couple of primitive 

    call give_poly_ij(k,l,P_new_kl,P_center_kl,p_exp_kl,fact_p_kl,iorder_p_kl,coef_prod_kl)
    call give_poly_ij(i,j,P_new_ij,P_center_ij,p_exp_ij,fact_p_ij,iorder_p_ij,coef_prod_ij)
    schwartz_kl(0,0) = 0.d0
    do r = 1, ao_prim_num(k)
      coef1 = ao_coef_normalized_ordered_transp(r,k)*ao_coef_normalized_ordered_transp(r,k)
      schwartz_kl(0,r) = 0.d0
      do s = 1, ao_prim_num(l)
        coef2 = coef1 * ao_coef_normalized_ordered_transp(s,l) * ao_coef_normalized_ordered_transp(s,l)
        qq = p_exp_kl(r,s)
        q_inv = 1.d0/qq
        schwartz_kl(s,r) = general_primitive_integral_erf_new(dim1,          &
            P_new_kl(0,1,r,s),P_center_kl(1,r,s),fact_p_kl(r,s),p_exp_kl(r,s),q_inv,iorder_p_kl(1,r,s),                 &
            P_new_kl(0,1,r,s),P_center_kl(1,r,s),fact_p_kl(r,s),p_exp_kl(r,s),q_inv,iorder_p_kl(1,r,s))      &
            * coef2
        schwartz_kl(s,r) = dabs(schwartz_kl(s,r))
        schwartz_kl(0,r) = max(schwartz_kl(0,r),schwartz_kl(s,r))
      enddo
      schwartz_kl(0,0) = max(schwartz_kl(0,r),schwartz_kl(0,0))
    enddo


    do p = 1, ao_prim_num(i)
      coef1 = ao_coef_normalized_ordered_transp(p,i)
      do q = 1, ao_prim_num(j)
        coef2 = coef1*ao_coef_normalized_ordered_transp(q,j)
        pp = p_exp_ij(p,q)
        p_inv = 1.d0/pp
        schwartz_ij = general_primitive_integral_erf_new(dim1,               &
            P_new_ij(0,1,p,q),P_center_ij(1,p,q),fact_p_ij(p,q),p_exp_ij(p,q),p_inv,iorder_p_ij(1,p,q),                 &
            P_new_ij(0,1,p,q),P_center_ij(1,p,q),fact_p_ij(p,q),p_exp_ij(p,q),p_inv,iorder_p_ij(1,p,q)) *               &
            coef2*coef2
        schwartz_ij = dabs(schwartz_ij)
        if (schwartz_kl(0,0)*schwartz_ij < thr) then
           cycle
        endif
        do r = 1, ao_prim_num(k)
          if (schwartz_kl(0,r)*schwartz_ij < thr) then
             cycle
          endif
          coef3 = coef2*ao_coef_normalized_ordered_transp(r,k)
          do s = 1, ao_prim_num(l)
            if (schwartz_kl(s,r)*schwartz_ij < thr) then
               cycle
            endif
            coef4 = coef3*ao_coef_normalized_ordered_transp(s,l)
            qq = p_exp_kl(r,s)
            q_inv = 1.d0/qq
            integral = general_primitive_integral_erf_new(dim1,              &
                P_new_ij(0,1,p,q),P_center_ij(1,p,q),fact_p_ij(p,q),p_exp_ij(p,q),p_inv,iorder_p_ij(1,p,q), & 
                P_new_kl(0,1,r,s),P_center_kl(1,r,s),fact_p_kl(r,s),p_exp_kl(r,s),q_inv,iorder_p_kl(1,r,s))
            ao_two_e_integral_schwartz_accel_erf_new = ao_two_e_integral_schwartz_accel_erf_new + coef4 * integral
          enddo ! s
        enddo  ! r
      enddo   ! q
    enddo    ! p

  else

    do p = 1, 3
      I_power(p) = ao_power(i,p)
      J_power(p) = ao_power(j,p)
      K_power(p) = ao_power(k,p)
      L_power(p) = ao_power(l,p)
    enddo
    double  precision              :: ERI_erf

    schwartz_kl(0,0) = 0.d0
    do r = 1, ao_prim_num(k)
      coef1 = ao_coef_normalized_ordered_transp(r,k)*ao_coef_normalized_ordered_transp(r,k)
      schwartz_kl(0,r) = 0.d0
      do s = 1, ao_prim_num(l)
        coef2 = coef1*ao_coef_normalized_ordered_transp(s,l)*ao_coef_normalized_ordered_transp(s,l)
        schwartz_kl(s,r) = ERI_erf(                                      &
            ao_expo_ordered_transp(r,k),ao_expo_ordered_transp(s,l),ao_expo_ordered_transp(r,k),ao_expo_ordered_transp(s,l),&
            K_power(1),L_power(1),K_power(1),L_power(1),             &
            K_power(2),L_power(2),K_power(2),L_power(2),             &
            K_power(3),L_power(3),K_power(3),L_power(3)) * &
            coef2
        schwartz_kl(s,r) = dabs(schwartz_kl(s,r))
        schwartz_kl(0,r) = max(schwartz_kl(0,r),schwartz_kl(s,r))
      enddo
      schwartz_kl(0,0) = max(schwartz_kl(0,r),schwartz_kl(0,0))
    enddo

    do p = 1, ao_prim_num(i)
      coef1 = ao_coef_normalized_ordered_transp(p,i)
      do q = 1, ao_prim_num(j)
        coef2 = coef1*ao_coef_normalized_ordered_transp(q,j)
        schwartz_ij = ERI_erf(                                          &
                ao_expo_ordered_transp(p,i),ao_expo_ordered_transp(q,j),ao_expo_ordered_transp(p,i),ao_expo_ordered_transp(q,j),&
                I_power(1),J_power(1),I_power(1),J_power(1),         &
                I_power(2),J_power(2),I_power(2),J_power(2),         &
                I_power(3),J_power(3),I_power(3),J_power(3))*coef2*coef2
        schwartz_ij = dabs(schwartz_ij)
        if (schwartz_kl(0,0)*schwartz_ij < thr) then
           cycle
        endif
        do r = 1, ao_prim_num(k)
          if (schwartz_kl(0,r)*schwartz_ij < thr) then
             cycle
          endif
          coef3 = coef2*ao_coef_normalized_ordered_transp(r,k)
          do s = 1, ao_prim_num(l)
            if (schwartz_kl(s,r)*schwartz_ij < thr) then
               cycle
            endif
            coef4 = coef3*ao_coef_normalized_ordered_transp(s,l)
            integral = ERI_erf(                                          &
                ao_expo_ordered_transp(p,i),ao_expo_ordered_transp(q,j),ao_expo_ordered_transp(r,k),ao_expo_ordered_transp(s,l),&
                I_power(1),J_power(1),K_power(1),L_power(1),         &
                I_power(2),J_power(2),K_power(2),L_power(2),         &
                I_power(3),J_power(3),K_power(3),L_power(3))
            ao_two_e_integral_schwartz_accel_erf_new = ao_two_e_integral_schwartz_accel_erf_new +  coef4 * integral
          enddo ! s
        enddo  ! r
      enddo   ! q
    enddo    ! p

  endif
  deallocate (schwartz_kl)

end

